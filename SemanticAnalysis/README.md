## Semantic Analysis

The semantic analyzer is designed to detect and report errors in the code, such as type mismatches, division by zero, and undeclared variables.

To keep track of variables and their types, the semantic analysis uses a symbol table. The symbol table stores information about each variable, such as its name, type, and scope (well we have just one scope in this project ðŸŒš). 

The semantic analysis uses the symbol table to check for type mismatches and undeclared variables. The `SymbolTable.hpp` node looks like this 

```c++
class Node
{
    public:
        LexerToken node;
        std::variant<InferredType, std::monostate> inferredType;
        std::shared_ptr<Node> next;

        Node(LexerToken node) : node(node), inferredType(std::monostate{}), next(nullptr) {}
};
```

The semantic analysis also uses type inference to determine the type of each expression in the code. The type of variable allowed are only `int` and `float`.By analyzing the types of the operands and the operation being performed, the semantic analysis can infer the type of the expression. The inferred types are stored in the AST tree `node.hpp` and symbol table for later use.

```c++
enum class InferredType { INTEGER, FLOAT };

struct Node
{
    std::shared_ptr<Node> left;
    std::shared_ptr<Node> right;
    LexerToken type;
    std::variant<InferredType, std::monostate> inferredType;
};
```

### Summary of how it works
1.  The semantic analysis first traverses the AST tree generated by the syntax analysis.
2.  As it traverses the tree, it checks and adds variables to the symbol table.
3.  The semantic analysis then performs type inference on each expression in the code.
4.  The inferred types are stored in the AST tree and symbol table for later use.
5.  This means the output of the semantic analyzer is still an AST tree ðŸ˜… but this is an error free, typed inferred AST tree

__To learn more:__
#### [CuriousX Semantic Analysis Blog](https://jenniferchukwu.com/posts/semanticAnalysis)

